<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ùïè-remove</title>
    <!-- jquery -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <!-- Text box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/material.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/lint/lint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/fold/foldgutter.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/lint/lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/fold/brace-fold.min.js"></script>
    <!-- Materialize CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/2.1.5/css/dataTables.dataTables.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/colresizable/colResizable-1.6.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <!-- Markdown handling -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Data tables -->
    <script src="https://cdn.datatables.net/2.1.5/js/dataTables.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/colresizable/colResizable-1.6.min.js"></script>

    <!-- Auth data -->
    <script>
    const AUTH_DATA_KEY = "auth-data";

    class AuthenticationData {
        constructor(user_id, headers, lastUpdated = null) {
            this.user_id = user_id
            this.headers = headers
            this.lastUpdated = lastUpdated || new Date();
        }

        /**
        * Parse the authentication data from the fetch function string.
        * @param {string} fetchFunctionString - The fetch function string.
        * @returns {AuthenticationData} - The authentication data object.
        */
        static fromRemoveFollowerFetchNodeJsCode(fetchFunctionString) {
            const parsedFn = parseFetchFollowerFunction(fetchFunctionString);
            var obj = new AuthenticationData(
                getUserIdCookie(parsedFn.func.options.headers.cookie),
                parsedFn.func.options.headers
            );
            return obj;
        }

        setStorage() {
            localStorage.setItem(
                AUTH_DATA_KEY,
                JSON.stringify(this)
            );
        }

        updateFromJSON(jsonData) {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;

            for (const [key, value] of Object.entries(data)) {
                if (this.hasOwnProperty(key)) {
                    this[key] = value;
                }
            }
        }

        getCookiesObject() {
            // Parse the cookies from the headers
            const cookies = this.headers.cookie.split(';').map(cookie => cookie.trim());
            return Object.fromEntries(cookies.map(cookie => cookie.split('=')));
        }

        /**
        * Load the authentication data from local storage.
        * @returns {AuthenticationData} - The authentication data object.
        */
        static fromStorage() {
            var authData = localStorage.getItem(AUTH_DATA_KEY);
            if (authData) {
                authData = JSON.parse(authData);
                if (new Date() - new Date(authData.lastUpdated) > 24 * 60 * 60 * 1000) {
                    return null;
                }
                return new AuthenticationData(
                    authData.user_id,
                    authData.headers,
                    new Date(authData.lastUpdated)
                );
            }
            return null;
        }

        static clearStorage() {
            localStorage.removeItem(AUTH_DATA_KEY);
        }
    }

    /**
    * Parse the 'twid' value from the cookie string.
    * @param {string} cookie - The cookie string.
    * @returns {string|null} - The parsed 'twid' value or null if not found.
    */
    function getUserIdCookie(cookie) {
        const match = cookie.match(/twid=u%3D(\d+)/);
        return match ? match[1] : null;
    }

    function formatCookies(cookies) {
        return Object.entries(cookies)
        .map(([key, value]) => {
            if (typeof value === 'string') {
                return `${key}="${value.replace(/"/g, '\\"')}"`;
            }
            return `${key}=${String(value)}`;
        })
        .join('; ');
    }

    /**
    * Parse the fetch followers function string to get the URL, variables, features, headers, referrer, referrerPolicy, body, method, mode, and credentials.
    * @param {string} fetchFunctionString - The fetch function string.
    * @returns {object} - The parsed fetch function object 
    * 
    */
    function parseFetchFollowerFunction(fetchFunctionString) {
        const parsedFn = fetchFunctionString.match(/(?<fn>[a-zA-Z_]*[a-zA-Z0-9_]*)\(\s*["'`](?<url>[^"'`]*?)["'`]\s*,\s*(?<options>\{.*\})\s*\)/s).groups;
        return {
            func: {
                name: parsedFn.fn,
                url: parsedFn.url,
                // options: Object.fromEntries(parsedFn.options.split(',').map(opt => opt.split(':').map(val => val.trim())))
                options: JSON.parse(parsedFn.options),
            },
            request: parseFollowersURL(parsedFn.url)
        }
    }

    /**
    * Parse the fetch URL to get the URL, variables, and features.
    * @param {string} fetchUrl - The fetch URL.
    * @returns {object} - The parsed fetch URL object with the URL, variables, and features.
    * 
    * @example
    * const fetchUrl = "https://api.twitter.com/graphql?variables=%7B%22userId%22%3A%22123456789%22%7D&features=%5B%22user%22%5D";
    * const parsedFetchURL = parseFetchURL(fetchUrl);
    * console.log(parsedFetchURL);
    * // {
    * //     url: "https://api.twitter.com/graphql",
    * //     params: {
    * //         variables: { userId: "123456789" },
    * //         features: ["user"]
    * //     }
    * // }
    */
    function parseFetchURL(fetchUrl) {
        const urlObj = new URL(fetchUrl);

        const variablesParam = urlObj.searchParams.get("variables");
        const featuresParam = urlObj.searchParams.get("features");

        var variables = {};
        if (variablesParam !== null) {
            const decodedVariables = decodeURIComponent(variablesParam);
            variables = JSON.parse(decodedVariables)
        }

        var features = [];
        if (featuresParam !== null) {
            const decodedFeatures = decodeURIComponent(featuresParam);
            features = JSON.parse(decodedFeatures);
        }

        return {
            url: urlObj.origin + urlObj.pathname,
            params: {
                variables: variables,
                features: features,
                other: urlObj.searchParams
            }
        };
    }

    /**
    * Parse the followers URL to get the URL.
    * @param {string} followersUrl - The followers URL.
    * @returns {object} - The parsed followers URL object with the URL, variables, and features.
    *
    * @example
    * const followersUrl = "https://api.twitter.com/graphql/123456789/Followers?variables=%7B%22userId%22%3A%22123456789%22%7D&features=%5B%22user%22%5D";
    * const parsedFollowersURL = parseFollowersURL(followersUrl);
    * console.log(parsedFollowersURL);
    * // {
    * //     url: "https://api.twitter.com/graphql",
    * //     params: {
    * //         variables: { userId: "123456789" },
    * //         features: ["user"]
    * //     }
    * // }
    */
    function parseFollowersURL(followersUrl) {
        var urlObj = parseFetchURL(followersUrl);
        return urlObj;
    }

    var auth = null;

    $(document).ready(function() {
        // Initialize the database
        auth = AuthenticationData.fromStorage();
    });
    </script>

    <!-- Local storage -->
    <script>
    const FOLLOWER_DATABASE_KEY = "followerDatabase";

    class Database {
        constructor() {
            this.followers = {};
            this.lastUpdated = new Date().toISOString();
        }

        /**
        * Create a new follower database in local storage. Overwrites the existing database.
        * @returns {object} - The new database object.
        */
        static createDatabase() {
            let new_db = new Database();
            localStorage.setItem(
                FOLLOWER_DATABASE_KEY,
                JSON.stringify(new_db)
            );
            return new_db;
        }

        updateFromJSON(jsonData) {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            
            for (const [key, value] of Object.entries(data)) {
              if (this.hasOwnProperty(key)) {
                this[key] = value;
              }
            }
          }

        /**
        * Load the follower database from local storage. If it doesn't exist, create a new database. If the database is older than 24 hours, create a new database.
        * @returns {object} - The follower database object.
        */
        static fromStorage() {
            var db_obj = localStorage.getItem(FOLLOWER_DATABASE_KEY);
            if (db_obj) {
                db_obj = JSON.parse(db_obj);
                // If the database is older than 24 hours, create a new database
                if (new Date() - new Date(db_obj.lastUpdated) > 24 * 60 * 60 * 1000) {
                    return this.createDatabase();
                }
                db = new Database();
                db.updateFromJSON(db_obj);
                return db;
            }
            return this.createDatabase();
        }

        setDatabase(update_time = true) {
            if (update_time) {
                this.lastUpdated = new Date().toISOString();
            }
            localStorage.setItem(
                FOLLOWER_DATABASE_KEY,
                JSON.stringify(this)
            );
        }

        /**
        * Add a follower to the follower database. Overwrites the existing follower if it exists.
        * @param {object} follower - The follower object.
        */
        addFollower(follower, update_storage = true) {
            this.followers[follower.x_id] = follower;
            if (update_storage) {
                this.setDatabase();
            }
        }

        /**
        * Remove a follower from the follower database.
        * @param {string} x_id - The follower's X ID.
        */
        removeFollower(x_id) {
            this.followers.removeItem(x_id);
            this.setDatabase();
        }

        /**
        * Get all followers from the follower database.
        * @returns {object} - The followers object.
        * @param {boolean} retain_is_removed - Whether to retain the existing is_removed attribute if overwriting.
        * @param {boolean} update_storage - Whether to update the local storage after adding the follower.
        */
        upsertFollower(follower, retain_is_removed = false, update_storage = true) {
            if (this.followers.hasOwnProperty(follower.x_id)) {
                if (retain_is_removed) {
                    follower.is_removed = this.followers[follower.x_id].is_removed;
                }
                for (const [key, value] of Object.entries(follower)) {
                    this.followers[follower.x_id][key] = value;
                }
            } else {
                this.followers[follower.x_id] = follower;
            }
            if (update_storage) {
                this.setDatabase();
            }
        }

        /**
        * Add multiple followers to the follower database. Overwrites the existing followers if they exist.
        * @param {object} followers - The followers object.
        * @param {boolean} retain_is_removed - Whether to retain the existing is_removed attribute if overwriting.
        * @param {boolean} update_storage - Whether to update the local storage after adding the followers.
        */
        upsertFollowers(followers, retain_is_removed = false, update_storage = true) {
            followers.forEach(follower => {
                this.upsertFollower(follower, retain_is_removed, false);
            });
            if (update_storage) {
                this.setDatabase();
            }
        }

        /**
        * Get all existing followers from the follower database.
        * @returns {object} - The followers object.
        */
        getNonRemovedFollowers() {
            return Object.values(this.followers).filter(f => !f.is_removed);
        }

        /**
        * Get all removed followers from the follower database.
        * @returns {object} - The followers object.
        */
        getRemovedFollowers() {
            return Object.values(this.followers).filter(f => f.is_removed);
        }

    }

    var db = null;

    $(document).ready(function() {
        // Initialize the database
        var db = Database.fromStorage();
    });
    </script>

    <!-- Cursor state (local storage) -->
    <script>
        const CURSOR_STATE_KEY = "cursor-history";

        class CursorState {
            constructor(history = null) {
                this.history = history || [];
            }

            current() {
                return this.history[this.history.length - 1] || null;
            }

            push(cursor) {
                this.history.push(cursor);
                this.toStorage();
            }

            toStorage() {
                localStorage.setItem(
                    CURSOR_STATE_KEY,
                    JSON.stringify(this)
                );
            }

            static fromStorage() {
                var cursor_history = localStorage.getItem(CURSOR_STATE_KEY);
                if (cursor_history) {
                    cursor = new CursorState(JSON.parse(cursor_history).history);
                    return cursor;
                }
                cursor_history = new CursorState();
                cursor_history.toStorage();
                return cursor_history;
            }

            getNextSortIndex() {
                var cur = this.current();
                if (!cur) {return null;}
                return cur.bottom ? cur.bottom.value: null;
            }

            getPrevSortIndex() {
                var cur = this.current();
                if (!cur) {return null;}
                return cur.top ? cur.top.value: null;
            }
        }

        var cursor = null;
        $(document).ready(function() {
            // Initialize the cursor
            cursor = CursorState.fromStorage();
        });

    </script>

    <!-- X Followers -->
     <script>
    
    class XFollower {
        constructor(
            x_id,
            name,
            screen_name,
            followers_count,
            friends_count,
            has_graduated_access,
            is_blue_verified,
            following,
            profile_image_url_https,
            created_at,
            is_removed
        ) {
            this.x_id = x_id;
            this.name = name;
            this.screen_name = screen_name;
            this.followers_count = followers_count;
            this.friends_count = friends_count;
            this.has_graduated_access = has_graduated_access;
            this.is_blue_verified = is_blue_verified;
            this.following = following;
            this.profile_image_url_https = profile_image_url_https;
            this.created_at = created_at;
            this.is_removed = is_removed;
        }

        /**
        * Create a new XFollower object from an 'entry' JSON object from the Twitter API.
        * @param {object} entry - The JSON object.
        * @returns {XFollower} - The XFollower object.
        */
        static fromEntryJSON(entry) {
            if (entry.content.cursorType) {
                return null;
            }
            const user = entry.content.itemContent.user_results.result;
            const legacy = user.legacy;
            return new XFollower(
                user.rest_id,
                legacy.name,
                legacy.screen_name,
                legacy.followers_count,
                legacy.friends_count,
                user.has_graduated_access,
                user.is_blue_verified || legacy.verified,
                legacy.following,
                legacy.profile_image_url_https.replace("_normal", "_400x400"),
                transformDateTime(legacy.created_at),
                false
            );
        }

        /**
        * Create many new XFollower objects from an array of 'entry' JSON objects from the Twitter API.
        * @param {list[object]} entries - The JSON objects.
        * @returns {list} - The XFollower objects.
        */
        static manyFromEntryJSON(entries) {
            return entries.map(entry => XFollower.fromEntryJSON(entry)).filter(x => x !== null);
        }
    }

    /**
    * Parse the followers from the Twitter API response.
    * @param {object} response - The Twitter API response object.
    * @returns {list} - The XFollower objects.
    */
    function parseFromTwitterFollowersResponse(response) {
        return XFollower.manyFromEntryJSON(
            response.data.user.result.timeline.timeline.instructions.slice(-1)[0].entries
        );
    }

    /**
    * Transform a datetime string to a date string.
    * @param {string} datetimeStr - The datetime string.
    * @returns {string} - The date string.
    */
    function transformDateTime(datetimeStr) {
        // Parse the input datetime string
        const date = new Date(datetimeStr);
    
        // Extract year, month, and day
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
        const day = String(date.getDate()).padStart(2, '0');
    
        // Format into YYYY-MM-DD
        const formattedDate = `${year}-${month}-${day}`;
    
        return formattedDate;
    }
    </script>
    <!-- X API methods -->
    <script>

        /**
        * Remove a follower from the X API.
        * @param {string} follower_x_id - The follower's X ID.
        * @returns {boolean} - Whether the follower was removed successfully.
        */
        async function removeFollower(follower_x_id) {
            if (!auth) {
                alert("API authentication data is not set.");
                return false;
            }
            const url = '/remove';
            const headers = {
                'Content-Type': 'application/json',
            };
            const body = JSON.stringify({
                user_id: auth.user_id,
                target_user_id: follower_x_id,
                headers: auth.headers,
            });

            return fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            }).then(
                response => {
                    if (response.ok) {
                        console.log('Follower removed successfully:', response.json());
                        db.upsertFollower({ x_id: follower_x_id, is_removed: true }, false, false);
                        return true;
                    } else {
                        console.error('Failed to remove follower:', response.json());
                        return false;
                    }
                }
            ).catch(
                error => {
                    console.error('Failed to remove follower', follower_x_id, ':', error);
                    return false;
                }
            );
        }

        /**
        * List followers from the X API.
        * @param {number} n - The number of followers to list.
        * @returns {boolean} - Whether the followers were listed successfully.
        */
        async function listFollowers(n=50) {
            if (!auth) {
                alert("API authentication data is not set.");
                return false;
            }
            const url = '/list';
            const headers = {
                'Content-Type': 'application/json',
            };
            const body = JSON.stringify({
                user_id: auth.user_id,
                headers: auth.headers,
                cursor: cursor.getNextSortIndex(),
                count: n,
            });

            return fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            }).then(
                response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to list followers');
                    }
                }
            );
        }

        /*
        * Parses the cursors from an X follower list response.
        * @param {string} response - The X follower list response.
        * @returns {object} - The cursors object with top and bottom cursors.
        * 
        * @example
        * const response = {...};
        * const cursors = parseCursorsFromResponse(response);
        * console.log(cursors);
        * // {
        * //     top: { cursorType: "Top", value: "123456789" },
        * //     bottom: { cursorType: "Bottom", value: "987654321" }
        * // }
        */
        function parseCursorsFromResponse(response) {
            var cursorArray = response.data.user.result.timeline.timeline.instructions.slice(-1)[0].entries.filter(entry => entry.content.cursorType);
            var cursors = {
                top: null,
                bottom: null
            };
            if (cursorArray.length > 0) {
                if (cursorArray.length > 2) {
                    console.log("More than 2 cursors found in response");
                }
                cursorArray.forEach(cursorEntry => {
                    if (cursorEntry.content.cursorType === "Top") {
                        cursors.top = cursorEntry.content;
                    } else if (cursorEntry.content.cursorType === "Bottom") {
                        cursors.bottom = cursorEntry.content;
                    }
                });
            } else {
                console.log("No cursor found in response");
            }
            return cursors;
        }
    </script>
    <style>
        .CodeMirror {
            width: 100%;
            height: 30vh;
            max-height: 50vh;
            overflow-y: auto;
            resize: vertical;
            padding: 10px;
            border-radius: 6px;
        }
        table.dataTable thead th {
            background-color: #f5f5f5;
        }
        .container {
            padding-bottom: 20px;
        }
        .profile-pic {
            transition: transform 0.3s ease 0.2s;
        }
        .profile-pic:hover {
            transform: scale(2.5);
        }
        .api-auth-data-summary {
            /*background-color: rgb(24, 24, 24); /* Dark gray background */
            border-radius: 4px; /* Rounded corners */
            padding: 10px;
            font-size: 8pt; /* 8 pt font size */
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;
            display: flex;
            justify-content: space-between;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .api-auth-data-summary.active {
            color: #ee6e73;
        }
        .api-auth-data-summary.inactive {
            color: #efa750;
        }
        #apiAuthDataLeft, #apiAuthDataRight {
            width: 48%;
        }
        #apiAuthDataLeft {
            text-align: left;
        }
        #apiAuthDataRight {
            text-align: right;
        }
        </style>
</head>
<body>
    <div class="container">
        <h1 class="center-align">ùïè-remove</h1>
        <p class="center-align" style="opacity: 40%;">Remove ùïè bots en masse.</p>

        <!-- Tabs Navigation -->
        <ul class="tabs">
            <li class="tab col s3"><a href="#tab1">Home</a></li>
            <li class="tab col s3"><a href="#tab2">Help</a></li>
        </ul>

        <!-- Tab 1 Content -->
        <div id="tab1" class="col s12">
            <form id="javascriptForm">
                <div class="input-field">
                    <textarea id="js_form_input" name="js_form_input" class="materialize-textarea" rows="4">// Example fetch (Node.js) function
fetch(
    "https://api.twitter.com/graphql/123xyz456cba789/Followers?variables=%7B%22userId%22%3A%22987654321%22%7D&features=%5B%22user%22%5D",
    {
        "headers": {
            "x-csrf-token": "abc123",
            "authorization": "456def"
        }
    }
)</textarea>
                </div>
            </form>
            <div class="center-align" style="display:flex; justify-content: space-between;">
                <div><button  type="submit" id="extractAuth" class="btn waves-effect waves-light blue">Extract Auth</button></div>
                <button type="submit" id="userAddButton" class="btn waves-effect waves-light blue">Load Followers</button>
                <div><button type="button" id="resetAuthButton" class="btn waves-effect waves-light blue">Reset Auth</button></div>
            </div>
            <br>
            <div id="apiAuthSummarySection">
                <div id="apiAuthSummary" class="api-auth-data-summary inactive">
                    <div id="apiAuthDataLeft"></div>
                    <div id="apiAuthDataRight"></div>
                </div>
            </div>    
        </div>

        <!-- Tab 2 Content -->
        <div id="tab2" class="col s12" style="padding-bottom:2vw;">
            <div id="markdown-content" class="html cm-s-material CodeMirror CodeMirror-scroll">
                <div style="margin: 7%;">
Like lice removal but for bot followers on ùïè.

##### How to use

1. Open the developer console (F12), go to the "Network" tab, and open your followers page on ùïè.
1. Find the Fetch/XHR request to the "/Followers" endpoint.
1. Right-click the request and copy the request as "fetch (Node.js)".
1. Paste the copied fetch function into the ùïè-remove text box in the Home tab.
1. Click "Extract Auth" to extract the session details.
1. Click "Load Followers" to load some followers.
1. Tick boxes of followers to remove and click "Remove Selected Followers".

!!! warning !!!

You can't undo follower removals. Don't muck it up.

##### Pointers

To blaze through removal, double-click the checkbox of the first follower. Double tap TAB to go to the next follower and hit SPACE to tick the follower's removal box.
                </div>
            </div>
        </div>
        <br>
        <div>
            <label for="verified-filter">Has Twitter Blue:</label>
            <br>
            <select id="verified-filter">
                <option value="*">Not Selected</option>
                <option value="true">True</option>
                <option value="false">False</option>
            </select>
        </div>
        <table id="followersTable" class="striped highlight">
            <thead>
                <tr>
                    <th></th>
                    <th></th>
                    <th>Name</th>
                    <th>Verified</th>
                    <th>Screen Name</th>
                    <th>Followers Count</th>
                    <th>Following Count</th>
                    <th>Created At</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table content goes here -->
            </tbody>
        </table>
        <br>
        <div class="center-align">
            <button id="removeFollowersButton" class="btn waves-effect waves-light red lighten-1">Remove Selected Followers</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var elems = document.querySelectorAll('.tabs');
            var instances = M.Tabs.init(elems);
        });
    </script>
    <div class="container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            M.AutoInit();
        });

        var js_editor = CodeMirror.fromTextArea(document.getElementById('js_form_input'), {
            mode: "application/javascript",
            lineNumbers: true,
            foldGutter: true,
            theme: "material",
            gutters: ["CodeMirror-lint-markers", "CodeMirror-foldgutter"],
            lint: true,
            extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        });

    </script>
    <script>
        $.fn.dataTable.ext.order['verified-sort'] = customVerifiedSort;
        var followersTable = $('#followersTable').DataTable({
            // https://datatables.net/reference/option/
            scrollY: '56vh',
            paging: false,
            autoWidth: true,
            columnDefs: [
                // https://datatables.net/reference/option/columnDefs
                { width: '6%', targets: 0, searchable: false, className: 'select-checkbox' }, // Checkbox column
                { width: '6%', targets: 1, searchable: false, orderable: false }, // Profile picture column
                { width: '28%', targets: 2 }, // Name column
                { width: '5%', targets: 3, searchable: false, orderDataType: 'verified-sort' },  // Verified column
                { width: '15%', targets: 4 }, // Screen name column
                { width: '10%', targets: 5, searchable: false }, // Followers count column
                { width: '10%', targets: 6, searchable: false }, // Friends count column
                { width: '15%', targets: 7, searchable: false },  // Created at column
                { width: '0%', targets: 8, visible: false } // rest_id column
            ],
            order: [[2, 'asc']],
            dom: '<"top"f>rt<"bottom"ip><"clear">', // Move the search bar to the left
        });

        // Table functions
        function mk_pfp_url(user) {
            return `<a href="https://x.com/${user.screen_name}"><img src="${user.profile_image_url_https}" alt="Profile Picture" class="circle profile-pic" width="50" height="50"></a>`;
        }

        const verifiedCheckmark = `<div style="display: flex; justify-content: center; align-items: center; height: 100%;" is_verified=true><svg style="fill: rgb(29, 155, 240);max-height: 20px;max-width: 20px;" viewBox="0 0 22 22" aria-label="Verified account" role="img" data-testid="icon-verified"><g><path d="M20.396 11c-.018-.646-.215-1.275-.57-1.816-.354-.54-.852-.972-1.438-1.246.223-.607.27-1.264.14-1.897-.131-.634-.437-1.218-.882-1.687-.47-.445-1.053-.75-1.687-.882-.633-.13-1.29-.083-1.897.14-.273-.587-.704-1.086-1.245-1.44S11.647 1.62 11 1.604c-.646.017-1.273.213-1.813.568s-.969.854-1.24 1.44c-.608-.223-1.267-.272-1.902-.14-.635.13-1.22.436-1.69.882-.445.47-.749 1.055-.878 1.688-.13.633-.08 1.29.144 1.896-.587.274-1.087.705-1.443 1.245-.356.54-.555 1.17-.574 1.817.02.647.218 1.276.574 1.817.356.54.856.972 1.443 1.245-.224.606-.274 1.263-.144 1.896.13.634.433 1.218.877 1.688.47.443 1.054.747 1.687.878.633.132 1.29.084 1.897-.136.274.586.705 1.084 1.246 1.439.54.354 1.17.551 1.816.569.647-.016 1.276-.213 1.817-.567s.972-.854 1.245-1.44c.604.239 1.266.296 1.903.164.636-.132 1.22-.447 1.68-.907.46-.46.776-1.044.908-1.681s.075-1.299-.165-1.903c.586-.274 1.084-.705 1.439-1.246.354-.54.551-1.17.569-1.816zM9.662 14.85l-3.429-3.428 1.293-1.302 2.072 2.072 4.4-4.794 1.347 1.246z"></path></g></svg></div>`;

        function getVerifiedCheckmark(is_verified) {
            if (is_verified) {
                return verifiedCheckmark;
            }
            return `<div style="display: flex; justify-content: center; align-items: center; height: 100%;" is_verified=false></div>`;
        }

        function customVerifiedSort(settings, col) {
            return this.api().column(col, { order: 'index' }).nodes().map(function(td, i) {
                // Check if the cell contains an SVG element
                return $('svg', td).length ? 0 : 1;
            });
        }

        function updateAuthDataSummary() {
            const apiAuthSummary = document.getElementById('apiAuthSummary');
            const apiAuthDataLeft = document.getElementById('apiAuthDataLeft');
            const apiAuthDataRight = document.getElementById('apiAuthDataRight');

            if (auth) {
                const lastUpdated = auth.lastUpdated.toLocaleString(
                    'en-US',
                    {
                        month: 'long',
                        day: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    }
                ).replace(/, (\d{2}:\d{2} [APM]{2})$/, ' at $1');

                // Format the API data into two columns
                const leftColumn = `user-id: ${auth.user_id}\nauthorization: Bearer ${auth.headers['authorization'].slice(7, 11)}***${auth.headers['authorization'].slice(-4)}\ncursor-prev:${cursor.getPrevSortIndex()}`;
                const rightColumn = `${lastUpdated}  :last-updated\n\n${cursor.getNextSortIndex()}   :cursor-next`;

                // Update the API data summary
                apiAuthDataLeft.innerText = leftColumn;
                apiAuthDataRight.innerText = rightColumn;

                // Set the active class
                apiAuthSummary.classList.add('active');
                apiAuthSummary.classList.remove('inactive');
            } else {
                // Clear the API data summary
                apiAuthDataLeft.innerText = 'No API authentication data set';
                apiAuthDataRight.innerText = '';

                // Set the inactive class
                apiAuthSummary.classList.add('inactive');
                apiAuthSummary.classList.remove('active');
            }
        }

        async function updateTableAsyncBatch(users, batchSize = 25) {
            console.log(`Updating table for ${users.length} user(s)`);

            const userBatches = [];

            // Split users into batches
            for (let i = 0; i < users.length; i += batchSize) {
                userBatches.push(users.slice(i, i + batchSize));
            }

            for (const batch of userBatches) {
                await Promise.all(batch.map(async (user) => {
                    var row = followersTable.row((idx, data) => data[8] === user.x_id);
                    var data = row.data();
                    if (data) {
                        if (user.is_removed) {
                            // Remove row
                            row.remove().draw();
                            return;
                        }
                        // Update existing row
                        row.data([
                            data[0],
                            mk_pfp_url(user),
                            user.name,
                            getVerifiedCheckmark(user.is_blue_verified),
                            "@" + user.screen_name,
                            user.followers_count,
                            user.friends_count,
                            user.created_at,
                            user.x_id
                        ]);
                    } else {
                        if (user.is_removed) {
                            return;
                        }
                        // Add new row
                        followersTable.row.add([
                            `<label><input type="checkbox" name="row-checkbox" value=false><span></span></label>`,
                            mk_pfp_url(user),
                            user.name,
                            getVerifiedCheckmark(user.is_blue_verified),
                            "@" + user.screen_name,
                            user.followers_count,
                            user.friends_count,
                            user.created_at,
                            user.x_id
                        ]);
                    }
                }));
            }
            followersTable.draw();
        }

        function updateTable(users) {
            console.log(`Updating table with ${users.length} user(s)`);
            users.forEach(user => {
                var row = followersTable.row((idx, data) => data[8] === user.x_id);
                var data = row.data();
                if (data) {
                    if (user.is_removed) {
                        // Remove row
                        row.remove().draw();
                        return;
                    }
                    // Update existing row
                    row.data([
                        data[0],
                        mk_pfp_url(user),
                        user.name,
                        getVerifiedCheckmark(user.is_blue_verified),
                        "@" + user.screen_name,
                        user.followers_count,
                        user.friends_count,
                        user.created_at,
                        user.x_id
                    ]).draw();
                } else {
                    if (user.is_removed) {
                        return;
                    }
                    // Add new row
                    followersTable.row.add([
                        `<label><input type="checkbox" name="row-checkbox" value=false><span></span></label>`,
                        mk_pfp_url(user),
                        user.name,
                        getVerifiedCheckmark(user.is_blue_verified),
                        "@" + user.screen_name,
                        user.followers_count,
                        user.friends_count,
                        user.created_at,
                        user.x_id
                    ]).draw();
                }
            }); 
        }

        $(document).ready(function() {
            // Update table with existing users
            updateTableAsyncBatch(db.getNonRemovedFollowers()).then(() => {
                console.log("Table initialized");
            });
        });
        $(document).ready(function() {
            // Update API data summary
            updateAuthDataSummary();
        });
    </script>
    <!-- Event listeners -->
    <script>
        $(document).ready(function() {
            document.getElementById('userAddButton').addEventListener('click', function(event) {
                event.preventDefault(); // Prevent the default form submission
                listFollowers().then((followers) => {
                    // pulling straight from the API so retain is_removed
                    db.upsertFollowers(parseFromTwitterFollowersResponse(followers), false, true);
                    console.log("Adding users from JSON form data");
                    updateTableAsyncBatch(db.getNonRemovedFollowers()).then(
                        () => {
                            console.log("Table updated with new users")
                            cursor.push(parseCursorsFromResponse(followers));
                            updateAuthDataSummary();
                        }
                    );
                });
            });
        });

        $(document).ready(function() {
            document.getElementById('extractAuth').addEventListener('click', function(event) {
                event.preventDefault(); // Prevent the default form submission
                var js = js_editor.getValue();
                try {
                    auth = AuthenticationData.fromRemoveFollowerFetchNodeJsCode(js);
                    auth.setStorage();
                    updateAuthDataSummary();
                } catch (e) {
                    console.log(e);
                    alert("Invalid JavaScript: " + e);
                    return;
                }
            });
        });

        $(document).ready(function() {
            // Add filter for Verified column. Just filters based on the is_verified attribute we
            // set in the getVerifiedCheckmark function.
            $('#verified-filter').on('change', function() {
                var filterValue = $(this).val();
                console.log("Filtering verified: ", filterValue);
                if (filterValue === "*") {
                    followersTable.column(3).search("").draw();
                    return;
                } else if (filterValue !== "true" && filterValue !== "false") {
                    error("Invalid filter value: ", filterValue);
                    return;
                }
                followersTable.column(3).search(
                    function(searchVal, row) {
                        var cell = row.at(3);
                        return $(cell).attr("is_verified") === filterValue;
                    }
                ).draw();
            });
        });

        $(document).ready(function() {
            // Remove followers
            $('#removeFollowersButton').click(function() {
                console.log("Removing selected followers");
                var selectedFollowers = followersTable.rows(
                    ":has(input[type='checkbox']:checked)"
                ).data().toArray().map(
                    row => {
                        return {
                            x_id: row[8],
                            is_removed: false,
                        };
                    }
                );
                var nRemovedFollowers = 0;
                const removalPromises = selectedFollowers.map(item => 
                    removeFollower(item.x_id).then((was_removed) => {
                        nRemovedFollowers += was_removed ? 1 : 0;
                    }).catch((error) => {
                        console.error("Failed to remove follower:", error);
                    })
                );

                Promise.all(removalPromises).then(() => {
                    if (nRemovedFollowers > 0) {
                        console.log(`Updating ${nRemovedFollowers} removed user(s) in database`);
                        db.setDatabase();
                        updateTableAsyncBatch(db.getRemovedFollowers()).then(
                            () => console.log("Table updated with removed users")
                        );
                    } else {
                        console.log("No followers were removed");
                    }
                });
            });
        });

        $(document).ready(function() {
            // Reset API data button
            $('#resetAuthButton').click(function() {
                auth = null;
                AuthenticationData.clearStorage();
                updateAuthDataSummary();
            });
        });

        document.addEventListener("DOMContentLoaded", function() {
            var el = document.getElementById('markdown-content');
            el.innerHTML = marked.parse(el.innerText);
        });    
    </script>
</body>
</html>
